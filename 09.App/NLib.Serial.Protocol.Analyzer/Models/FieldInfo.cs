using System;
using System.Collections.Generic;
using System.Linq;

namespace NLib.Serial.Protocol.Analyzer.Models
{
    /// <summary>
    /// Represents a field definition within a protocol
    /// Used for defining how to parse specific data fields from packages
    /// </summary>
    public class FieldInfo
    {
        /// <summary>
        /// Field position/index within the protocol (0-based)
        /// </summary>
        public int Position { get; set; }

        /// <summary>
        /// Auto-generated name for the field (e.g., "Field0", "Field1")
        /// </summary>
        public string AutoGeneratedName { get; set; }

        /// <summary>
        /// User-defined field name (can be edited by user)
        /// </summary>
        public string Name { get; set; }

        /// <summary>
        /// Field name (must be valid C# identifier) - Legacy property
        /// </summary>
        public string FieldName
        {
            get { return Name; }
            set { Name = value; }
        }

        /// <summary>
        /// List of sample values extracted from log data (as raw bytes)
        /// </summary>
        public List<byte[]> SampleValues { get; set; }

        /// <summary>
        /// Variance score (0 = constant, 1 = highly variable)
        /// </summary>
        public double Variance { get; set; }

        /// <summary>
        /// Detection confidence score (0-100%)
        /// </summary>
        public double DetectionConfidence { get; set; }

        /// <summary>
        /// List of detected relationships with other fields
        /// </summary>
        public List<string> Relationships { get; set; }

        /// <summary>
        /// Start index within the segment/package (0-based)
        /// </summary>
        public int StartIndex { get; set; }

        /// <summary>
        /// Length of the field in characters/bytes
        /// </summary>
        public int Length { get; set; }

        /// <summary>
        /// Data type of the field
        /// </summary>
        public DataType DataType { get; set; }

        /// <summary>
        /// Encoding type (for string fields)
        /// </summary>
        public EncodingType EncodingType { get; set; }

        /// <summary>
        /// Endian type (for numeric fields)
        /// </summary>
        public EndianType EndianType { get; set; }

        /// <summary>
        /// Format string for parsing/display (optional)
        /// </summary>
        public string Format { get; set; }

        /// <summary>
        /// Sample value as raw bytes (source of truth)
        /// </summary>
        public byte[] SampleBytes { get; set; }

        /// <summary>
        /// Sample value as hex string (computed from SampleBytes)
        /// Example: "02 41 00 64"
        /// </summary>
        public string SampleHex
        {
            get
            {
                if (SampleBytes == null || SampleBytes.Length == 0)
                    return string.Empty;
                return BitConverter.ToString(SampleBytes).Replace("-", " ");
            }
        }

        /// <summary>
        /// Sample value as text string (computed from SampleBytes using encoding)
        /// Example: "AB\x00d"
        /// </summary>
        public string SampleText
        {
            get
            {
                if (SampleBytes == null || SampleBytes.Length == 0)
                    return string.Empty;

                try
                {
                    var encoding = GetEncoding();
                    return encoding.GetString(SampleBytes);
                }
                catch
                {
                    return "[Binary Data]";
                }
            }
        }

        /// <summary>
        /// Segment index (if field belongs to a specific segment in multi-segment package)
        /// -1 means applies to whole package or single-package protocol
        /// </summary>
        public int SegmentIndex { get; set; }

        /// <summary>
        /// Description or notes about this field
        /// </summary>
        public string Description { get; set; }

        /// <summary>
        /// Sample values formatted as comma-separated text for display
        /// Converts bytes to string ONLY for UI display purposes
        /// </summary>
        public string SampleValuesText
        {
            get
            {
                if (SampleValues == null || SampleValues.Count == 0)
                    return "-";

                var displaySamples = new List<string>();
                foreach (var bytes in SampleValues.Take(3))
                {
                    if (bytes == null || bytes.Length == 0)
                        continue;

                    // Convert bytes to string for display only
                    // This is UI presentation, not parsing logic
                    string displayValue = System.Text.Encoding.ASCII.GetString(bytes);
                    displaySamples.Add(displayValue);
                }

                return displaySamples.Count > 0 ? string.Join(", ", displaySamples) : "-";
            }
        }

        /// <summary>
        /// Confidence formatted as percentage text
        /// </summary>
        public string ConfidenceText
        {
            get { return $"{DetectionConfidence:F1}%"; }
        }

        /// <summary>
        /// Variance formatted as text
        /// </summary>
        public string VarianceText
        {
            get { return $"{Variance:F3}"; }
        }

        /// <summary>
        /// Constructor
        /// </summary>
        public FieldInfo()
        {
            Position = 0;
            AutoGeneratedName = string.Empty;
            Name = string.Empty;
            SampleValues = new List<string>();
            Variance = 0.0;
            DetectionConfidence = 0.0;
            Relationships = new List<string>();
            StartIndex = 0;
            Length = 0;
            DataType = DataType.String;
            EncodingType = EncodingType.ASCII;
            EndianType = EndianType.LittleEndian;
            Format = string.Empty;
            SampleBytes = null;
            SegmentIndex = -1;
            Description = string.Empty;
        }

        /// <summary>
        /// Constructor with basic parameters
        /// </summary>
        /// <param name="fieldName">Field name</param>
        /// <param name="startIndex">Start index</param>
        /// <param name="length">Length</param>
        /// <param name="dataType">Data type</param>
        public FieldInfo(string fieldName, int startIndex, int length, DataType dataType)
        {
            FieldName = fieldName ?? string.Empty;
            StartIndex = startIndex;
            Length = length;
            DataType = dataType;
            EncodingType = EncodingType.ASCII;
            EndianType = EndianType.LittleEndian;
            Format = string.Empty;
            SampleBytes = null;
            SegmentIndex = -1;
            Description = string.Empty;
        }

        /// <summary>
        /// Gets the System.Text.Encoding based on EncodingType
        /// </summary>
        /// <returns>Encoding instance</returns>
        private System.Text.Encoding GetEncoding()
        {
            switch (EncodingType)
            {
                case EncodingType.ASCII:
                    return System.Text.Encoding.ASCII;
                case EncodingType.UTF8:
                    return System.Text.Encoding.UTF8;
                case EncodingType.UTF16:
                    return System.Text.Encoding.Unicode;
                case EncodingType.Latin1:
                    return System.Text.Encoding.GetEncoding("ISO-8859-1");
                default:
                    return System.Text.Encoding.ASCII;
            }
        }

        /// <summary>
        /// Validates if the field name is a valid C# identifier
        /// </summary>
        /// <returns>True if valid</returns>
        public bool IsValidFieldName()
        {
            if (string.IsNullOrEmpty(FieldName))
                return false;

            // Must start with letter or underscore
            if (!char.IsLetter(FieldName[0]) && FieldName[0] != '_')
                return false;

            // Must contain only letters, digits, underscores
            foreach (char c in FieldName)
            {
                if (!char.IsLetterOrDigit(c) && c != '_')
                    return false;
            }

            return true;
        }

        /// <summary>
        /// Gets a display string for this field
        /// </summary>
        /// <returns>Display string</returns>
        public string GetDisplayString()
        {
            return $"{FieldName} [{StartIndex}:{Length}] {DataType}";
        }
    }
}
