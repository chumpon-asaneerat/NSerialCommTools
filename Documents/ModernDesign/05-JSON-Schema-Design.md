# JSON Schema Design (Draft Notes)

**Document Version**: 0.1 (Draft)
**Last Updated**: 2025-10-19
**Status**: Placeholder for future design

---

## Critical Field Naming Requirements

**Requirement Source**: FR-4.6 in 00-Requirements-Specification.md

### Field Name Properties

Each field in the JSON definition must support:

```json
{
  "fields": [
    {
      "autoGeneratedName": "Field1",     // Generated by analyzer
      "name": "NetWeight",                // User-defined custom name
      "displayName": "Net Weight",        // Optional: For UI display
      "dataType": "decimal",
      "position": 0,
      "sampleValues": ["1.640", "1.645", "1.650"],
      "confidenceScore": 0.98,

      // Parse rules
      "parse": {
        "pattern": "^([\\d.]+)",
        "offset": 0,
        "length": 8,
        "encoding": "ASCII"
      },

      // Serialize rules
      "serialize": {
        "format": "{0:F3}",
        "padding": "left",
        "width": 8,
        "padChar": " "
      },

      "description": "Net weight value in kg",
      "required": true
    }
  ]
}
```

### Field Naming Rules (Validation)

**Auto-Generated Name** (internal use only):
- Format: "Field{n}" or "NumericField{n}", "StringField{n}"
- Always present
- Used for internal tracking
- Not used in final T class

**Custom Name** (user-defined):
- Used in generated code and NTerminal<T>/NDevice<T>
- Validation rules:
  - Must match C# identifier pattern: `^[a-zA-Z_][a-zA-Z0-9_]*$`
  - Cannot be C# keyword: class, int, string, void, etc.
  - Must be unique within definition
  - Recommended: PascalCase for consistency
- Default: If user doesn't rename, use autoGeneratedName
- Persisted in JSON file

**Display Name** (optional):
- Human-readable name for UI/documentation
- Can contain spaces and special characters
- Example: "Net Weight (kg)"

### Smart Naming Suggestions

The analyzer should suggest names based on content:

| Sample Values | Data Type | Suggested Name |
|--------------|-----------|----------------|
| 1.640, 1.645 | decimal | Weight |
| kg, g, lb | string | Unit |
| N, G, S | char | Status |
| 2023-11-07 | date | Date or MeasurementDate |
| 17:19:38 | time | Time or MeasurementTime |
| 0, 1, 2 | int | Counter or Index |

Algorithm (to be designed):
```
1. Check if all values are numeric → Suggest "Value" or "Measurement"
2. Check if values match unit patterns → Suggest "Unit"
3. Check if values are single chars → Suggest "Status" or "Code"
4. Check if values match date patterns → Suggest "Date"
5. Check if values match time patterns → Suggest "Time"
6. Default → "Field{position}"
```

---

## Complete JSON Schema (To Be Designed)

### Top-Level Structure
```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Serial Device Protocol Definition",
  "version": "1.0",

  "deviceInfo": { },
  "protocolInfo": { },
  "messages": [ ],
  "fields": [ ],
  "messageSequence": [ ],
  "commands": [ ]
}
```

---

## Bidirectional Field Definitions

Each field must support BOTH:
1. **Parse** (Device → Application): Extract value from bytes
2. **Serialize** (Application → Device): Format value to bytes

Example for "NetWeight" field:
```json
{
  "name": "NetWeight",
  "dataType": "decimal",

  "parse": {
    "method": "regex",
    "pattern": "^([\\d.]+)",
    "group": 1,
    "type": "decimal",
    "decimalFormat": "F3"
  },

  "serialize": {
    "method": "format",
    "formatString": "{0:F3}",
    "padding": "left",
    "width": 8,
    "padChar": " ",
    "alignment": "right"
  }
}
```

---

**Next Steps**:
- Define complete JSON schema
- Create examples for all sample devices
- Document all field types and their parse/serialize rules
- Define validation rules
- Create schema version migration strategy

See also:
- **00-Requirements-Specification.md** - Protocol Definition File Requirements
- **02-System-Architecture.md** - Protocol Definition Generator component
- **01-Production-Code-Analysis.md** - Real-world protocol examples
